#!/usr/bin/env bash

# --- SETTINGS AND SAFETY ---
set -o errexit     # Exit immediately if a command exits with a non-zero status.
set -o nounset     # Treat unset variables as an error.
set -o pipefail    # If any command in a pipeline fails, that return code is used.
if [[ "${TRACE-0}" == "1" ]]; then
    set -o xtrace  # Print commands and their arguments as they are executed (for debugging).
fi

# Ensure that the correct environment (BASH, not sh or another shell) is running
# This prevents errors if the script is invoked incorrectly (e.g., 'sh script.sh')
if [[ -z "${BASH_VERSION}" ]]; then
    echo "Error: This script requires Bash to run." >&2
    exit 1
fi

# --- HELP AND ARGUMENT PARSING ---

SCRIPT_NAME="$(basename "$0")"
readonly SCRIPT_NAME

usage() {
    local exit_code="$1"
    echo "Usage: ./${SCRIPT_NAME} start|stop|restart|log|edit|status

Manage Emacs daemon

"
    exit "$exit_code"
}

# At least one argument
if [ "$#" != 1 ] ; then
    usage 1
fi

# Show help if -h or --help is passed
if [[ "${1-}" =~ ^-*h(elp)?$ ]]; then
    usage 0 # Use '0' for clean help exit
fi

# --- INITIALIZATION ---

# Move into the directory containing the script.
# This ensures all relative paths referenced within the script are correct.
# Note: It uses the directory of the SCRIPT being EXECUTED, not the sourced file.
cd "$(dirname "$0")" || exit 1

# --- MAIN EXECUTION ---

main() {
    local command="$1"
    case "$command" in
        start|stop|restart|status)
            systemctl --user "$command" emacs.service
            ;;
        log)
            journalctl --user -u emacs.service
            ;;
        edit)
            emacsclient -c -a '' ~/.config/systemd/user/emacs.service
            ;;
        help)
            usage 0
            ;;
        *)
            usage 1
            ;;
    esac
}

main "$@"
